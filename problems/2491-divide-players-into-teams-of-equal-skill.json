{
  "title": "Divide Players Into Teams of Equal Skill",
  "problem_id": "2581",
  "frontend_id": "2491",
  "difficulty": "Medium",
  "problem_slug": "divide-players-into-teams-of-equal-skill",
  "topics": [
    "Array",
    "Hash Table",
    "Two Pointers",
    "Sorting"
  ],
  "description": "You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: skill = [3,2,5,1,3,4]\nOutput: 22\nExplanation: \nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: skill = [3,4]\nOutput: 12\nExplanation: \nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 * 4 = 12.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: skill = [1,1,2,3]\nOutput: -1\nExplanation: \nThere is no way to divide the players into teams such that the total skill of each team is equal.",
      "images": []
    }
  ],
  "constraints": [
    "2 <= skill.length <= 105",
    "skill.length is even.",
    "1 <= skill[i] <= 1000"
  ],
  "follow_ups": [],
  "hints": [
    "Try sorting the skill array.",
    "It is always optimal to pair the weakest available player with the strongest available player."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long dividePlayers(vector<int>& skill) {\n        \n    }\n};",
    "java": "class Solution {\n    public long dividePlayers(int[] skill) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def dividePlayers(self, skill):\n        \"\"\"\n        :type skill: List[int]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def dividePlayers(self, skill: List[int]) -> int:\n        ",
    "c": "long long dividePlayers(int* skill, int skillSize) {\n    \n}",
    "csharp": "public class Solution {\n    public long DividePlayers(int[] skill) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number[]} skill\n * @return {number}\n */\nvar dividePlayers = function(skill) {\n    \n};",
    "typescript": "function dividePlayers(skill: number[]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer[] $skill\n     * @return Integer\n     */\n    function dividePlayers($skill) {\n        \n    }\n}",
    "swift": "class Solution {\n    func dividePlayers(_ skill: [Int]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun dividePlayers(skill: IntArray): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int dividePlayers(List<int> skill) {\n    \n  }\n}",
    "golang": "func dividePlayers(skill []int) int64 {\n    \n}",
    "ruby": "# @param {Integer[]} skill\n# @return {Integer}\ndef divide_players(skill)\n    \nend",
    "scala": "object Solution {\n    def dividePlayers(skill: Array[Int]): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn divide_players(skill: Vec<i32>) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (divide-players skill)\n  (-> (listof exact-integer?) exact-integer?)\n  )",
    "erlang": "-spec divide_players(Skill :: [integer()]) -> integer().\ndivide_players(Skill) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec divide_players(skill :: [integer]) :: integer\n  def divide_players(skill) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Sorting\n\n#### Intuition\n\nWe have a `skill` array, and we need to form teams of two players, ensuring each team has the same combined skill level.\n\nFirst, we calculate the target skill level for each team. Since all teams should have equal skill and there are `n/2` teams (where `n` is the length of the `skill` array), we find the target by dividing the total of all skills by the number of teams.\n\nWith the target skill level set, our goal is to identify pairs of players whose skills add up to this target. A brute force method, where we test each player against every other player, would take too long and may not meet our constraints.\n\nTo improve efficiency, we should pair players with the lowest skills with those who have the highest skills. This approach helps us reach the target skill level, as the target is essentially the median of all skills. By matching the lowest-skilled player with the highest-skilled player, we increase the chance of achieving the target. The second-lowest skilled player should pair with the second-highest, and this pattern continues.A formal proof using the method of contradictionClaim: To balance each team with the required skill, we should pair the unmatched player of the lowest skill ($L$) with the unmatched player of the highest skill ($H$).\n\nProof by Contradiction:\n\nAssume the claim is false. This means there exists a valid solution where $L$ is not paired with $H$, but instead:\n\n1. $L$ is paired with some player $X$\n2. $H$ is paired with some player $Y$,\nwhere $X \\neq H$ and $Y \\neq L$\n\nLet S be the required sum of skills for each team. Given that this is a valid solution:\n\n$$L + X = S \\space\\space\\space \\ldots (1)$$\n\n$$H + Y = S \\space\\space\\space \\ldots (2)$$\n\nSince $H$ is the highest unmatched skill and $L$ is the lowest unmatched skill, we know:\n\n$$L \\leq Y < X \\leq H$$\n\nFrom Equation 1: $X = S - L$\n\nFrom Equation 2: $Y = S - H$\n\nSince $X \\leq H$, we can substitute this into Equation 1:\n\n$$L + H \\geq S  \\space\\space\\space \\ldots (3)$$\n\nSince $Y \\geq L$, we can substitute this into Equation 2:\n\n$$H + L \\leq S \\space\\space\\space \\ldots  (4)$$\n\nFrom Equations 3 and 4, we can conclude:\n\n$$L + H = S$$\n\nThis means that to produce a team with the required skill sum $S$, we need to pair $L$ with $H$.\nHowever, this contradicts our initial assumption that there exists a valid solution where $L$ is not paired with $H$.\n\nTherefore, our initial assumption must be false, and the claim must be true.To match players efficiently, we start by sorting the `skill` array. Next, we iterate through the array, pairing the `i`th player from the start with the `i`th player from the end to form teams. If the cumulative skill of any team does not equal the target skill, we determine that equal division is impossible and return -1. If all teams meet the target, we calculate each team's chemistry by multiplying the skill levels of its players. The final answer is the sum of all team chemistries.\n\nThe algorithm is visualized below:\n\n![sorting demonstration](../Figures/2491/sorted.png)\n\n#### Algorithm\n\n- Sort the input array `skill` in ascending order.\n- Initialize:\n  - a variable `n` to the length of the `skill` array.\n  - a variable `totalChemistry` to 0, which will store the sum of all team chemistries.\n- Calculate the `targetTeamSkill` by adding the first and last elements of the sorted array.\n- Iterate through the first half of the array:\n  - Calculate `currentTeamSkill` by adding the `i`-th element from the start and the `i`-th element from the end.\n  - If `currentTeamSkill` doesn't match `targetTeamSkill`, return -1.\n  - Calculate the chemistry of the current team by multiplying the skills of the two team members.\n  - Add the calculated chemistry to `totalChemistry`.\n- Return `totalChemistry` as the answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `skill`. \n\n- Time complexity: $(n \\cdot \\log n)$\n\n    Sorting the array takes $O(n \\cdot \\log n)$ time. The algorithm iterates through half of the array, which takes $O(n/2) = O(n)$ time. All operations within the loop are constant time operations. \n\n    Thus, the overall time complexity of the algorithm is $O(n \\cdot \\log n) + O(n) = (n \\cdot \\log n)$.\n\n- Space complexity: $O(S)$\n\n    The only additional space used is for the sorting algorithm. The space taken by the sorting algorithm ($S$) depends on the language of implementation:\n    - In Java, `Arrays.sort()` is implemented using a variant of the Quick Sort algorithm which has a space complexity of $O( \\log n)$.\n    - In C++, the `sort()` function is implemented as a hybrid of Quick Sort, Heap Sort, and Insertion Sort, with a worst-case space complexity of $O(\\log n)$.\n    - In Python, the `sort()` method sorts a list using the Timsort algorithm which is a combination of Merge Sort and Insertion Sort and has a space complexity of $O(n)$.\n\n---\n\n### Approach 2: Frequency Table\n\n#### Intuition\n\nWe know the target team skill before pairing players. Let’s call this target skill `s`. When matching a player with skill `x`, we need to find another player with skill `s - x`.\n\nOne way to implement this is by looping through the `skill` array for each player to find their matching skill. However, this approach won't meet the problem's constraints. We need an efficient method to check if a player with a specific skill exists.\n\nA frequency table works well here because it allows constant-time lookups. This table stores key-value pairs, where the key represents the skill value, and the value indicates how many players have that skill. While hash maps are common for frequency tables, we will use an array in this case due to the limited skill range (1000).\n\nIn our table, the index serves as the key (the skill value), and the value is the frequency from the `skill` array. We will iterate through the `skill` array and check for each skill's complement in the table. If we don’t find a complement, we conclude that forming a valid team is impossible and return -1. If we do find a complement, we calculate and accumulate the chemistry for each team. The total chemistry gives us the answer.\n\n#### Algorithm\n\n- Initialize:\n  - a variable `n` to the length of the input array `skill`.\n  - a variable `totalSkill` to 0.\n- Create an array `skillFrequency` of size 1001 to store the frequency of each skill level.\n- Iterate through the `skill` array:\n  - Add each player's skill to `totalSkill`.\n  - Increment the count for each skill level in `skillFrequency`.\n- Check if `totalSkill` is evenly divisible by `n/2`. If not, return -1.\n- Calculate `targetTeamSkill` by dividing `totalSkill` by `n/2`.\n- Initialize `totalChemistry` to 0.\n- Iterate through the `skill` array again:\n  - Set `partnerSkill` as `targetTeamSkill` minus the current skill.\n  - If no player with `partnerSkill` exists (frequency is 0), return -1.\n  - Add the product of the current skill and `partnerSkill` to `totalChemistry`.\n  - Decrement the frequency of `partnerSkill`.\n- Return half of `totalChemistry` (as each pair was counted twice).\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `skill`. \n\n* Time complexity: $O(n)$\n\n    The algorithm performs two passes through the array, each taking $O(n)$ time. All operations within these loops are constant time. Thus, the time complexity of the algorithm is $O(n)$.\n\n* Space complexity: $O(1)$\n\n    The most significant additional space used is the `skillFrequency` array. This array has a fixed size of $1001$, regardless of the input size, as it's based on the constraint that each player's skill is between $1$ and $1000$. The other variables used occupy constant space.\n\n    Since the extra space used doesn't grow with the input size, the space complexity is constant, $O(1)$.\n\n---\n\n### Approach 3: Map\n\n#### Intuition\n\nWhile iterating through the `skill` array, we often encounter duplicate pairs. For example, if the target value is 8 and we have two 3's and two 5's, the algorithm would consider each 3 separately to pair with each 5. We can improve this method.\n\nThe hash map already counts all skill values. Instead of pairing each skill separately, we can match them all at once. We will look at each key (skill value) in the map. For each key, we check if its complementary skill value is in the map and if their counts are equal. If the counts are not equal, the skill with the higher count will remain unmatched. If either condition fails, we cannot form the required pairs, and we return -1.\n\nIf both conditions are met, we can calculate the combined chemistry for all pairs at once. We add up these chemistry values as we go through the map and return the total as our answer.\n\n#### Algorithm\n\n- Initialize:\n  - a variable `n` to store the length of the `skill` array.\n  - a variable `totalSkill` to 0 to accumulate the sum of all skills.\n- Create a hash map `skillMap` to store the frequency of each skill value.\n- Iterate through each skill value in `skill`:\n  - Add the current skill to `totalSkill`.\n  - Update the frequency of the current skill in `skillMap`.\n- Check if `totalSkill` can be divided by `n/2`. If not, return -1.\n- Calculate the `targetSkill` by dividing `totalSkill` by half the number of players.\n- Initialize a variable `totalChemistry` to 0 to accumulate the sum of team chemistry.\n- Iterate through each unique skill value in `skillMap`:\n  - Get the frequency of the current skill as `currFreq`.\n  - Calculate `partnerSkill` by subtracting the current skill from `targetSkill`.\n  - Check if the frequency of `partnerSkill` matches `currFreq`:\n    - If not, return -1 as it's impossible to form valid teams.\n  - Calculate the chemistry for all pairs with this skill and add to `totalChemistry`.\n- Return half of `totalChemistry` as the final result.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the input array `skill`. \n\n* Time complexity: $O(n)$\n\n    The algorithm begins by iterating through the `skill` array to populate the frequency map, an operation that takes linear time. It then proceeds to iterate over the keys in the map, which, in the worst-case scenario (where each skill is unique), also takes $O(n)$ time.\n\n    Thus, the overall time complexity of the algorithm is $O(n)$.\n\n* Space complexity: $O(n)$\n\n    The only additional data structure used is the map, which can take $O(n)$ space in the worst case (every skill value is unique).\n\n---"
}