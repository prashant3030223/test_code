{
  "title": "Count Unguarded Cells in the Grid",
  "problem_id": "2343",
  "frontend_id": "2257",
  "difficulty": "Medium",
  "problem_slug": "count-unguarded-cells-in-the-grid",
  "topics": [
    "Array",
    "Matrix",
    "Simulation"
  ],
  "description": "You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.\nA guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.\nReturn the number of unoccupied cells that are not guarded.\nExample 1:\nExample 2:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\nOutput: 7\nExplanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\nOutput: 4\nExplanation: The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png"
      ]
    }
  ],
  "constraints": [
    "1 <= m, n <= 105",
    "2 <= m * n <= 105",
    "1 <= guards.length, walls.length <= 5 * 104",
    "2 <= guards.length + walls.length <= m * n",
    "guards[i].length == walls[j].length == 2",
    "0 <= rowi, rowj < m",
    "0 <= coli, colj < n",
    "All the positions in guards and walls are unique."
  ],
  "follow_ups": [],
  "hints": [
    "Create a 2D array to represent the grid. Can you mark the tiles that can be seen by a guard?",
    "Iterate over the guards, and for each of the 4 directions, advance the current tile and mark the tile. When should you stop advancing?"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\n        \n    }\n};",
    "java": "class Solution {\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countUnguarded(self, m, n, guards, walls):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type guards: List[List[int]]\n        :type walls: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\n        ",
    "c": "int countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize) {\n    \n}",
    "csharp": "public class Solution {\n    public int CountUnguarded(int m, int n, int[][] guards, int[][] walls) {\n        \n    }\n}",
    "javascript": "/**\n * @param {number} m\n * @param {number} n\n * @param {number[][]} guards\n * @param {number[][]} walls\n * @return {number}\n */\nvar countUnguarded = function(m, n, guards, walls) {\n    \n};",
    "typescript": "function countUnguarded(m: number, n: number, guards: number[][], walls: number[][]): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param Integer $m\n     * @param Integer $n\n     * @param Integer[][] $guards\n     * @param Integer[][] $walls\n     * @return Integer\n     */\n    function countUnguarded($m, $n, $guards, $walls) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countUnguarded(_ m: Int, _ n: Int, _ guards: [[Int]], _ walls: [[Int]]) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countUnguarded(m: Int, n: Int, guards: Array<IntArray>, walls: Array<IntArray>): Int {\n        \n    }\n}",
    "dart": "class Solution {\n  int countUnguarded(int m, int n, List<List<int>> guards, List<List<int>> walls) {\n    \n  }\n}",
    "golang": "func countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\n    \n}",
    "ruby": "# @param {Integer} m\n# @param {Integer} n\n# @param {Integer[][]} guards\n# @param {Integer[][]} walls\n# @return {Integer}\ndef count_unguarded(m, n, guards, walls)\n    \nend",
    "scala": "object Solution {\n    def countUnguarded(m: Int, n: Int, guards: Array[Array[Int]], walls: Array[Array[Int]]): Int = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {\n        \n    }\n}",
    "racket": "(define/contract (count-unguarded m n guards walls)\n  (-> exact-integer? exact-integer? (listof (listof exact-integer?)) (listof (listof exact-integer?)) exact-integer?)\n  )",
    "erlang": "-spec count_unguarded(M :: integer(), N :: integer(), Guards :: [[integer()]], Walls :: [[integer()]]) -> integer().\ncount_unguarded(M, N, Guards, Walls) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_unguarded(m :: integer, n :: integer, guards :: [[integer]], walls :: [[integer]]) :: integer\n  def count_unguarded(m, n, guards, walls) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Iterative Simulation\n\n#### Intuition\n\nWe want to determine which unoccupied cells are unguarded given a grid populated by guards, walls, and empty cells. \n\nThe vision of each guard is limited:\n- They can see every cell in the four cardinal directions from their position: north, east, south, and west. In other words, they cannot see diagonally.\n- They cannot see past walls. \n\nSince we are given the locations of the guards and walls in the grid, the simplest approach will be to simulate each guard's range of vision. We can iterate through each direction from the guard's position until we either reach the grid's boundary, encounter another guard, or a wall, which blocks the guard's line of sight. \n\nThe key things to keep in mind are:\n\n- Guards and walls occupy cells that cannot be guarded, so these should be distinctly marked.\n- For each guard, visibility should be checked in all four directions until an obstruction or the grid’s edge is reached.\n- Once all guarded cells are marked, any unmarked cells represent unguarded areas, which can then be counted to find the solution.\n\nThe following is a simulation of the approach, resulting in a final answer of 7 unguarded cells.\n\n!?!../Documents/2257/2257_count_unguard.json:755,470!?!\n\n#### Algorithm\n\n- Initialize constants:\n  - `UNGUARDED` (0): Represents an unguarded cell.\n  - `GUARDED` (1): Represents a cell that is guarded.\n  - `GUARD` (2): Represents a cell with a guard.\n  - `WALL` (3): Represents a wall cell.\n\n- Define the function `markguarded` to mark cells as guarded:\n  - Traverse upwards from the given `(row, col)` position:\n    - If the cell is a wall or already has a guard, stop marking.\n    - Otherwise, mark the cell as `GUARDED`.\n  - Traverse downwards, leftwards, and rightwards in a similar manner to mark all reachable cells as `GUARDED` from the given position.\n\n- Define the function `countUnguarded` to count unguarded cells:\n  - Initialize a grid of size `m x n`, where each cell is initially set to `UNGUARDED`.\n  - Mark the positions of guards in the grid as `GUARD`.\n  - Mark the positions of walls in the grid as `WALL`.\n  - For each guard, call `markguarded` to mark all cells that are guarded by that guard.\n  \n- After marking all guarded cells, iterate through the grid and count the number of cells that are still `UNGUARDED`.\n\n- Return the count of unguarded cells.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of rows, $n$ the number of columns, $g$ be the number of guards in the `guards` list, and $w$ be the number of walls in the `walls` list.\n\n- Time Complexity: $O(m \\cdot n)$\n\n    Initializing the grid of size $m \\times n$ takes $O(m \\cdot n)$.\n\n    Marking guards and walls in the grid requires iterating over the `guards` and `walls` arrays, which takes $O(g + w)$. However, since $g, w \\leq m \\cdot n$, this step is bounded by $O(m \\cdot n)$.\n\n    For each guard, the `markguarded` function traverses in four directions (up, down, left, right) but stops as soon as a wall, another guard, or the grid boundary is encountered. Each cell can be visited at most four times (once from each direction). Hence, marking all guarded cells is proportional to the total number of cells, taking $O(m \\cdot n)$.\n\n    Finally, counting the unguarded cells involves iterating over the entire grid, which also takes $O(m \\cdot n)$.\n\n    Combining all steps, the overall time complexity is: $O(m \\cdot n) + O(m \\cdot n) + O(m \\cdot n) = O(m \\cdot n)$.\n\n- Space Complexity: $O(m \\cdot n)$\n\n    The grid occupies $O(m \\cdot n)$ space. No additional space is used for recursion or other data structures, as the `markUnguarded` function uses iterative loops for marking cells.\n\n    Thus, the overall space complexity is $O(m \\cdot n)$.\n\n---\n\n### Approach 2: Recursive Way\n\n#### Intuition\n\nWe begin by marking the positions of the guards and walls in the grid, just like in the first approach. Then, for each guard, we trigger recursion in all four directions. Each recursive call will explore one direction as far as possible, marking all the reachable cells as \"guarded.\" The exploration stops when it encounters a wall or another guard, and we repeat this process with other guards.\n\nThere is not much difference between Approach 1 and Approach 2 on a fundamental level, apart from their implementation, so this is meant to showcase a different implementation.\n\n#### Algorithm\n\n- Initialize constants:\n  - `UNGUARDED` (0): Represents an unguarded cell.\n  - `GUARDED` (1): Represents a cell that is guarded.\n  - `GUARD` (2): Represents a cell with a guard.\n  - `WALL` (3): Represents a wall cell.\n\n- Define `recurse(row, col, grid, direction)` function to perform recursive Search:\n  - If `row` or `col` is out of bounds, or if the cell is a guard or a wall, return.\n  - Mark the current cell as `GUARDED`.\n  - Recursively call `recurse` for neighboring cells based on the given direction ('U', 'D', 'L', or 'R').\n\n- Define `countUnguarded(m, n, guards, walls)` to count the unguarded cells:\n  - Initialize a `grid` of size `m x n` with all cells set to `UNGUARDED`.\n  \n  - Mark the guards' positions in the `grid` by setting the respective cells to `GUARD`.\n  \n  - Mark the walls' positions in the `grid` by setting the respective cells to `WALL`.\n  \n  - For each guard:\n    - Call `recurse` to mark the cells as `GUARDED` by traversing in all four directions (Up, Down, Left, Right).\n  \n  - After marking all guarded cells, count the number of cells that are still `UNGUARDED` in the grid.\n  \n- Return the count of unguarded cells.\n\n#### Implementation#### Complexity Analysis\n\nLet $m$ be the number of rows, $n$ the number of columns, $g$ be the number of guards in the `guards` list, and $w$ be the number of walls in the `walls` list.\n\n- Time Complexity: $O(m \\cdot n)$\n    \n    Initializing the grid of size $m \\times n$ takes $O(m \\cdot n)$.\n    \n    Marking guards and walls in the grid involves iterating over the `guards` and `walls` arrays, which takes $O(g + w)$. Since $g, w \\leq m \\cdot n$, this step is bounded by $O(m \\cdot n)$ in the worst case.\n\n    When marking guarded cells, each cell in the grid can be visited at most four times (once for each possible direction: up, down, left, right) across all guards. This means that the total traversal across all guards is proportional to the number of cells in the grid, making the marking process $O(m \\cdot n)$.\n\n    Counting the unguarded cells at the end involves iterating through all cells in the grid, which takes $O(m \\cdot n)$.\n\n    Combining all these steps, the overall time complexity simplifies to $O(m \\cdot n)$.\n\n- Space Complexity: $O(m \\cdot n)$\n  \n    The primary space usage is the grid, which requires $O(m \\cdot n)$.\n    \n    The DFS recursion has a space complexity up to $O((m + n))$ due to the recursive stack in the worst case where it could traverse a straight line of unguarded cells. However, this is less significant than $O(m \\cdot n)$ in terms of space complexity.\n\n    Thus, the overall space complexity is $O(m \\cdot n)$.\n\n---\n\n### Approach 3: Visibility Axis\n\n#### Intuition\n\nTo approach this differently, we can spread visibility from each guard across the grid, row by row and column by column. At first, all cells are considered unguarded. As we go through each row and column, we update the grid to show which areas each guard can see. The important thing is that when a guard marks a cell as \"guarded,\" it’s only marked once. If another guard later sees the same cell, we don’t mark it again since it has already been marked. This helps avoid doing the same work twice.\n\nThe process happens in two main steps: first, we check rows, and then we check columns. In each step, we only update visibility in the direction we’re focusing on. Once a guard marks a cell as \"guarded,\" it won’t be marked again.\n\nFor example, if Guard A can see cell (2, 3), we mark it as \"guarded.\" Later, if Guard B can also see cell (2, 3), we don’t mark it again because Guard A already did. This method makes the process more efficient by preventing unnecessary marking.\n\n#### Algorithm\n\n- Initialize constants:\n  - `UNGUARDED` (0): Represents an unguarded cell.\n  - `GUARDED` (1): Represents a cell that is guarded.\n  - `GUARD` (2): Represents a cell with a guard.\n  - `WALL` (3): Represents a wall cell.\n\n- Initialize a 2D grid `grid` of size `m x n` with all cells set to `UNGUARDED`.\n\n- Mark the positions of guards in the grid:\n  - For each guard in `guards`, set `grid[guard[0]][guard[1]] = GUARD`.\n\n- Mark the positions of walls in the grid:\n  - For each wall in `walls`, set `grid[wall[0]][wall[1]] = WALL`.\n\n- Define a helper function `updateCellVisibility` to handle updating visibility of cells:\n  - If a cell contains a guard (`GUARD`), return `true`.\n  - If a cell contains a wall (`WALL`), return `false`.\n  - Otherwise, if the line of sight is active, mark the cell as `GUARDED`.\n\n- Perform horizontal passes over the grid:\n  - For each row:\n    - Traverse from left to right, updating visibility based on the guard's position.\n    - Traverse from right to left, updating visibility again for the row.\n\n- Perform vertical passes over the grid:\n  - For each column:\n    - Traverse from top to bottom, updating visibility based on the guard's position.\n    - Traverse from bottom to top, updating visibility again for the column.\n\n- Iterate through the entire grid and count cells that are still marked as `UNGUARDED`.\n\n- Return the count of unguarded cells.\n\n#### Implementation\n\n> Java does not allow nested function definitions directly inside another function. To fix this, the helper function updateCellVisibility was moved outside of the countUnguarded method.#### Complexity Analysis\n\nLet $m$ be the number of rows, $n$ the number of columns, $g$ be the number of guards in the `guards` list, and $w$ be the number of walls in the `walls` list.\n\n- Time complexity: $O(m \\times n)$\n\n    The first loop marks the positions of the guards, which takes $O(g)$ times. However, since we're iterating through the grid's dimensions, the overall complexity for this part remains $O(m \\times n)$.\n    \n    The second loop marks the positions of the walls, similarly taking $O(w)$ time, but again the overall time complexity remains $O(m \\times n)$ for iterating through the grid.\n\n    The third set of loops processes the horizontal and vertical passes over the grid, where each pass involves iterating over all cells in the grid, resulting in $O(m \\times n)$ for each direction (horizontal and vertical). Since we have two directions, the total complexity for this part is $O(2 \\times m \\times n) = O(m \\times n)$.\n    \n    Finally, the grid is scanned again to count the unguarded cells, which takes $O(m \\times n)$.\n\n    Therefore, the overall time complexity is $O(m \\times n)$.\n\n- Space complexity: $O(m \\times n)$\n\n    The primary space used by the algorithm is the `grid`, which has dimensions $m \\times n$. This grid stores the state for each cell (unguarded, guarded, guard, or wall). Hence, the space complexity is dominated by the space needed for the grid, which is $O(m \\times n)$.\n\n    Additionally, the `updateCellVisibility` function uses constant space, and there are no other significant data structures contributing to space usage. Thus, the space complexity is $O(m \\times n)$.\n\n---"
}