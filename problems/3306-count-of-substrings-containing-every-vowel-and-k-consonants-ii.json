{
  "title": "Count of Substrings Containing Every Vowel and K Consonants II",
  "problem_id": "3569",
  "frontend_id": "3306",
  "difficulty": "Medium",
  "problem_slug": "count-of-substrings-containing-every-vowel-and-k-consonants-ii",
  "topics": [
    "Hash Table",
    "String",
    "Sliding Window"
  ],
  "description": "You are given a string word and a non-negative integer k.\nReturn the total number of substrings of word that contain every vowel ('a', 'e', 'i', 'o', and 'u') at least once and exactly k consonants.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: word = \"aeioqq\", k = 1\nOutput: 0\nExplanation:\nThere is no substring with every vowel.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: word = \"aeiou\", k = 0\nOutput: 1\nExplanation:\nThe only substring with every vowel and zero consonants is word[0..4] , which is \"aeiou\" .",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: word = \" ieaouqqieaouqq \", k = 1\nOutput: 3\nExplanation:\nThe substrings with every vowel and one consonant are:",
      "images": []
    }
  ],
  "constraints": [
    "5 <= word.length <= 2 * 105",
    "word consists only of lowercase English letters.",
    "0 <= k <= word.length - 5"
  ],
  "follow_ups": [],
  "hints": [
    "We can use sliding window and binary search.",
    "For each index <code>r</code>, find the maximum <code>l</code> such that both conditions are satisfied using binary search."
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    long long countOfSubstrings(string word, int k) {\n        \n    }\n};",
    "java": "class Solution {\n    public long countOfSubstrings(String word, int k) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def countOfSubstrings(self, word, k):\n        \"\"\"\n        :type word: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def countOfSubstrings(self, word: str, k: int) -> int:\n        ",
    "c": "long long countOfSubstrings(char* word, int k) {\n    \n}",
    "csharp": "public class Solution {\n    public long CountOfSubstrings(string word, int k) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} word\n * @param {number} k\n * @return {number}\n */\nvar countOfSubstrings = function(word, k) {\n    \n};",
    "typescript": "function countOfSubstrings(word: string, k: number): number {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $word\n     * @param Integer $k\n     * @return Integer\n     */\n    function countOfSubstrings($word, $k) {\n        \n    }\n}",
    "swift": "class Solution {\n    func countOfSubstrings(_ word: String, _ k: Int) -> Int {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun countOfSubstrings(word: String, k: Int): Long {\n        \n    }\n}",
    "dart": "class Solution {\n  int countOfSubstrings(String word, int k) {\n    \n  }\n}",
    "golang": "func countOfSubstrings(word string, k int) int64 {\n    \n}",
    "ruby": "# @param {String} word\n# @param {Integer} k\n# @return {Integer}\ndef count_of_substrings(word, k)\n    \nend",
    "scala": "object Solution {\n    def countOfSubstrings(word: String, k: Int): Long = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn count_of_substrings(word: String, k: i32) -> i64 {\n        \n    }\n}",
    "racket": "(define/contract (count-of-substrings word k)\n  (-> string? exact-integer? exact-integer?)\n  )",
    "erlang": "-spec count_of_substrings(Word :: unicode:unicode_binary(), K :: integer()) -> integer().\ncount_of_substrings(Word, K) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec count_of_substrings(word :: String.t, k :: integer) :: integer\n  def count_of_substrings(word, k) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview \n\nGiven a string `word` and an integer `k`, we need to find the total number of substrings of `word` that satisfy **two requirements**:\n\n1. The substring must contain **every vowel** (`a, e, i, o, u`). Each vowel can appear any number of times in the substring.\n2. The substring must have **exactly `k` consonants** (any character that is not a vowel).\n\nThis type of problem is common in substring and subarray searches, where we look for all occurrences that meet a specific set of constraints. Some related problems include:\n\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n- [2461. Maximum Sum of Distinct Subarrays With Length K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/)  \n\nSince we are dealing with substrings and need to enforce specific constraints efficiently, we can use the sliding window technique, which allows us to dynamically adjust the window size while keeping track of the required conditions.\n\n> NOTE: Our solution must run in linear time, as the brute force approach has cubic time complexity and is inefficient. This problem is nearly identical to **[3305. Count of Substrings Containing Every Vowel and K Consonants I](https://leetcode.com/problems/count-of-substrings-containing-every-vowel-and-k-consonants-i/description/)**, except that the word length constraint has been increased from 250 to 200,000.\n\n---\n\n### Approach 1: Sliding Window\n\n#### Intuition\n\nA brute force approach would involve manually going through every substring of `word` and checking if each substring satisfies the 2 requirements listed. However, this is inefficient because it repeatedly processes overlapping substrings. Instead of looking at every possible substring, we can use a sliding window to track and update information dynamically as we scan through `word`. \n\nOur sliding window maintains two pointers, `start` and `end`, to define the starting and ending index of the current substring. The window expands by moving `end` forward and shrinks by moving `start` forward as we search for all occurrences of a valid substring. We can keep a `numValidSubstrings` variable to count the total number of valid substrings we see in our window.\n\nTo determine if a window contains a valid substring, we track two values: \n- `vowelCount`: A frequency map storing how many times each vowel appears in the window.  \n- `consonantCount`: A counter tracking the number of consonants in the window. \n\nOur window would contain a valid substring when `vowelCount` contains all five vowels and `consonantCount` is exactly `k`. \n\nAt the start, our window is empty. As we iterate through `word`, we expand the window by adding the current character at `end`. If it is a vowel, we update `vowelCount`. If it is a consonant, we increase `consonantCount`. As we expand there are 3 possible cases:\n\n- `consonantCount < k` or `vowelCount` doesn't have all vowels yet: This will happen in the early iterations of the sliding window process when the window is still small. In this case, we don't have to make adjustments and can continue expanding.\n\n- `consonantCount > k`: If `consonantCount` becomes too large, we need to shrink our window by moving `start` forward and removing elements from the beginning. As we remove each element, we adjust `consonantCount` and `vowelCount` accordingly. Once a vowel's count goes to 0, we remove it from `vowelCount`. Once the window is back within valid constraints, we resume expanding.\n\n- `consonantCount == k` and `vowelCount` contains all vowels: This means we have found a window with a valid substring. Let's consider how we can adjust our substring to find more valid substrings.\n    - **Expanding**: If we expand to another vowel, we know that this new substring is also valid. If the new character is a consonant, `consonantCount` exceeds `k` and we no longer have a valid substring. Thus, we can continue expanding our `end` boundary to find new substrings until we encounter a consonant. Precisely, if the next consonant is at index `nextConsonantIndex`, then we have a total of `nextConsonantIndex - end` new valid substrings. Instead of manually iterating to find the next consonant each time, we can precompute an array `nextConsonant`, where `nextConsonant[i]` stores the index of the next consonant after index `i`. With this, we can quickly determine how many new valid substrings can be formed from any valid window.  \n    - **Shrinking**: We can find more valid substrings by shrinking our window until we no longer have a valid substring. For each new shrunken window, we can reapply the expanding logic discussed above, and create `nextConsonant[end] - end` new windows. \n\nIn summary, when we come across a valid window, we can keep shrinking while the window is still valid. For each shrunken window, we have `nextConsonant - end` more valid windows. \n\nAfter we have iterated through all characters of `word`, we have successfully found all valid substrings.\n\n#### Algorithm\n\n- Initialize `numValidSubstrings` = 0` to count total number of valid substrings.\n- Initialize `start = 0` and `end = 0` to represent the start and end of our sliding window.\n- Initialize map `vowelCount` to keep track of the frequency of the 5 vowels in our sliding window.\n- Initialize `consonantCount` to keep track of the number of consonants in our sliding window.\n- Initialize array `nextConsonant` to hold the index of next consonant for all indices. \n- Create helper function `isVowel(char c)` to return whether or not a character is a vowel\n- Populating `nextConsonant`:\n    - We initialize `nextConsonantIndex` to a default value of `word.length()`\n    - We iterate through `word` backwards using `i = word.length() - 1` to index. For each `i`:\n        - `nextConsonant[i] = nextConsonantIndex`.\n        - If `word[i]` is a consonant (`isVowel(word[i]) == false`), update `nextConsonantindex = i`.\n- Start the sliding window process. While `end < word.length()`:\n    - Get new letter: `newLetter = word[end]`.\n    - Update counts with the new letter:\n        - If `isVowel(newLetter)`, then increment corresponding frequency in `vowelCount`.\n        - Otherwise, increment `consonantCount`: `consonantCount++`.\n    - While `consonantCount > k`, shrink our window:\n        - Get first letter in window: `startLetter = word[start]`.\n        - Remove it from the window:\n            - If `isVowel(startLetter)`, then decrement corresponding frequency in `vowelCount`. If the frequency reaches 0, delete `startLetter` from `vowelCount`.\n            - Otherwise, decrement `consonantCount`: `consonantCount--`.\n            - Shrink the window by 1: `start++`.\n    - While we have a valid window, keep shrinking and count the total number of valid substrings found:\n        - Add `nextConsonant[end] - end` to `numValidSubstrings`. This is the total number of valid substrings with the given `start`.\n        - Get first letter in window: `startLetter = word[start]`.\n        - Remove it from the window:\n            - If `isVowel(startLetter)`, then decrement corresponding frequency in `vowelCount`. If the frequency reaches 0, delete `startLetter` from `vowelCount`.\n            - Otherwise, decrement `consonantCount`: `consonantCount--`.\n            - Shrink the window by 1: `start++`.\n    - Increment `end` to add the next character to our window: `end++`\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `word`.\n\n* Time Complexity: $O(N)$\n\n    Our initial pass to populate `nextConsonant` takes $O(N)$ time. The sliding window process has a total of $N$ iterations. For each iteration, we update `vowelCount` and `consonantCount` for the new character we add, which takes $O(1)$ time. We also perform a variable number of iterations to shrink our window for each iteration (either from having too many consonants or because we have found a valid window and want to find more). All operations we do when shrinking (updating `vowelCount` and `consonantCount`, looking up `nextConsonant` values, and adding to `numValidSubstrings`) all take $O(1)$ time. Because we know that the total number of shrink iterations done is bounded by $N$. Thus, the total time complexity is $O(N)$. \n\n* Space Complexity: $O(N)$\n\n    We require extra space for our `nextConsonant` array and our `vowelCount` map. `nextConsonant` has a size of $N$ and `vowelCount` has a constant size of `5`. Thus, the total space complexity is $O(N)$.\n\n---\n\n### Approach 2: Sliding Window (Relaxed Constraints)\n\n#### Intuition\n\nIn the previous approach, we adjusted our sliding window by strictly following the 2 constraints:\n\n1. A valid window must contain all vowels.\n2. A valid window must contain exactly `k` consonants.\n\nThe second requirement introduces more complexity to our sliding window solution, leading us to precompute a `nextConsonant` array to keep track of when the next consonant occurs for all indices in the string. To simplify the problem, let's relax this second constraint, so that valid substrings have **at least** `k` consonants instead.\n\nLetâ€™s say we find a window (substring) that contains all vowels and exactly `k` consonants. What happens if we keep expanding the window to the right?\n\n- Adding more characters will never remove a vowel from the window.  \n- It may add more consonants, but since we only need at least `k`, the window remains valid.  \n\nThis means that once we reach our first valid window (where `end` is the right boundary of the window), every substring that extends from this point onward is also valid. Instead of checking each one individually, we can instantly count them:\n\n$\\text{New valid substrings} = \\text{word.length} - \\text{end}$\n\nAfter counting these substrings, we shrink the window from the left (`start` index) and repeat the process, making sure our window remains valid.  \n\nNow, the question is how we can connect this relaxed version of the problem back to the original problem. Let's denote the solution to this relaxed problem with a given `word` and `k` as `atLeastK(word, k)`. The key observation is the number of valid substrings (with exactly `k` consonants) is equal to `atLeastK(word, k) - atLeastK(word, k + 1)`.\n\nWith this problem reduction, we can simplify our sliding window approach and eliminate the need for an auxiliary data structure to keep track of occurrences of consonants.\n\n#### Algorithm\n\n- Create helper function `isVowel(char c)` to return whether or not a character is a vowel.\n- Create helper function `atLeastK(word, k)`:\n    - Initialize `numValidSubstrings` = 0 to count total number of valid substrings.\n    - Initialize `start = 0` and `end = 0` to represent the start and end of our sliding window.\n    - Initialize map `vowelCount` to keep track of the frequency of the 5 vowels in our sliding window.\n    - Initialize `consonantCount` to keep track of the number of consonants in our sliding window.\n    - Start the sliding window process. While `end < word.length()`:\n        - Get new letter: `newLetter = word[end]`.\n        - Update counts with the new letter:\n            - If `isVowel(newLetter)`, then increment corresponding frequency in `vowelCount`.\n            - Otherwise, increment `consonantCount`: `consonantCount++`.\n        - While `vowelCount.size() == 5 && consonantCount >= k`:\n            - Count the valid substrings: `numValidSubstrings += word.length() - end`.\n            - Get first letter in window: `startLetter = word[start]`.\n            - Remove it from the window:\n                - If `isVowel(startLetter)`, then decrement corresponding frequency in `vowelCount`. If the frequency reaches 0, delete `startLetter` from `vowelCount`.\n                - Otherwise, decrement `consonantCount`: `consonantCount--`.\n                - Shrink the window by 1: `start++`.\n        - Increment `end` to add the next character to our window: `end++`.\n- Return `atLeast(word, k) - atLeast(word, k + 1)`.\n\n#### Implementation#### Complexity Analysis\n\nLet $N$ be the size of `word`.\n\n* Time Complexity: $O(N)$\n\n    Similar to approach 1, the sliding window process has a total of $N$ operations where each iteration involves constant time operations. We perform the sliding window process twice. Thus, the total time complexity is $O(N)$. \n\n* Space Complexity: $O(1)$\n\n    We do not use any auxiliary data structures, so the space complexity is $O(1)$.\n\n---"
}