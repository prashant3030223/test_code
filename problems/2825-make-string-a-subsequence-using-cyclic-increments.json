{
  "title": "Make String a Subsequence Using Cyclic Increments",
  "problem_id": "3018",
  "frontend_id": "2825",
  "difficulty": "Medium",
  "problem_slug": "make-string-a-subsequence-using-cyclic-increments",
  "topics": [
    "Two Pointers",
    "String"
  ],
  "description": "You are given two 0-indexed strings str1 and str2.\nIn an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'.\nReturn true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise.\nNote: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: str1 = \"abc\", str2 = \"ad\"\nOutput: true\nExplanation: Select index 2 in str1.\nIncrement str1[2] to become 'd'. \nHence, str1 becomes \"abd\" and str2 is now a subsequence. Therefore, true is returned.",
      "images": []
    },
    {
      "example_num": 2,
      "example_text": "Input: str1 = \"zc\", str2 = \"ad\"\nOutput: true\nExplanation: Select indices 0 and 1 in str1. \nIncrement str1[0] to become 'a'. \nIncrement str1[1] to become 'd'. \nHence, str1 becomes \"ad\" and str2 is now a subsequence. Therefore, true is returned.",
      "images": []
    },
    {
      "example_num": 3,
      "example_text": "Input: str1 = \"ab\", str2 = \"d\"\nOutput: false\nExplanation: In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once. \nTherefore, false is returned.",
      "images": []
    }
  ],
  "constraints": [
    "1 <= str1.length <= 105",
    "1 <= str2.length <= 105",
    "str1 and str2 consist of only lowercase English letters."
  ],
  "follow_ups": [],
  "hints": [
    "<div class=\"_1l1MA\">Consider the indices we will increment separately.</div>",
    "<div class=\"_1l1MA\">We can maintain two pointers: pointer <code>i</code> for <code>str1</code> and pointer <code>j</code> for <code>str2</code>, while ensuring they remain within the bounds of the strings.</div>",
    "<div class=\"_1l1MA\">If both <code>str1[i]</code> and <code>str2[j]</code> match, or if incrementing <code>str1[i]</code> matches <code>str2[j]</code>, we increase both pointers; otherwise, we increment only pointer <code>i</code>.</div>",
    "<div class=\"_1l1MA\">It is possible to make <code>str2</code> a subsequence of <code>str1</code> if <code>j</code> is at the end of <code>str2</code>, after we can no longer find a match.</div>"
  ],
  "code_snippets": {
    "cpp": "class Solution {\npublic:\n    bool canMakeSubsequence(string str1, string str2) {\n        \n    }\n};",
    "java": "class Solution {\n    public boolean canMakeSubsequence(String str1, String str2) {\n        \n    }\n}",
    "python": "class Solution(object):\n    def canMakeSubsequence(self, str1, str2):\n        \"\"\"\n        :type str1: str\n        :type str2: str\n        :rtype: bool\n        \"\"\"\n        ",
    "python3": "class Solution:\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        ",
    "c": "bool canMakeSubsequence(char* str1, char* str2) {\n    \n}",
    "csharp": "public class Solution {\n    public bool CanMakeSubsequence(string str1, string str2) {\n        \n    }\n}",
    "javascript": "/**\n * @param {string} str1\n * @param {string} str2\n * @return {boolean}\n */\nvar canMakeSubsequence = function(str1, str2) {\n    \n};",
    "typescript": "function canMakeSubsequence(str1: string, str2: string): boolean {\n    \n};",
    "php": "class Solution {\n\n    /**\n     * @param String $str1\n     * @param String $str2\n     * @return Boolean\n     */\n    function canMakeSubsequence($str1, $str2) {\n        \n    }\n}",
    "swift": "class Solution {\n    func canMakeSubsequence(_ str1: String, _ str2: String) -> Bool {\n        \n    }\n}",
    "kotlin": "class Solution {\n    fun canMakeSubsequence(str1: String, str2: String): Boolean {\n        \n    }\n}",
    "dart": "class Solution {\n  bool canMakeSubsequence(String str1, String str2) {\n    \n  }\n}",
    "golang": "func canMakeSubsequence(str1 string, str2 string) bool {\n    \n}",
    "ruby": "# @param {String} str1\n# @param {String} str2\n# @return {Boolean}\ndef can_make_subsequence(str1, str2)\n    \nend",
    "scala": "object Solution {\n    def canMakeSubsequence(str1: String, str2: String): Boolean = {\n        \n    }\n}",
    "rust": "impl Solution {\n    pub fn can_make_subsequence(str1: String, str2: String) -> bool {\n        \n    }\n}",
    "racket": "(define/contract (can-make-subsequence str1 str2)\n  (-> string? string? boolean?)\n  )",
    "erlang": "-spec can_make_subsequence(Str1 :: unicode:unicode_binary(), Str2 :: unicode:unicode_binary()) -> boolean().\ncan_make_subsequence(Str1, Str2) ->\n  .",
    "elixir": "defmodule Solution do\n  @spec can_make_subsequence(str1 :: String.t, str2 :: String.t) :: boolean\n  def can_make_subsequence(str1, str2) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Overview\n\nWe need to find if `str2` can be made a subsequence of `str1` by performing at most one cyclic increment operation on any character of `str1`.\n\nBefore diving into the approaches, let's first understand two key concepts: the definition of a subsequence and the cyclic nature of characters.\n\n##### 1. Subsequence Definition\n\nA subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, `\"ace\"` is a subsequence of `\"abcde\"` because you can obtain `\"ace\"` by removing `'b'` and `'d'` from `\"abcde\"` while maintaining the order of the remaining characters.\n\n##### 2. Cyclic Nature of Characters\n\nThe cyclic nature of characters refers to the wrap-around behavior in the alphabet. Specifically, when you increment a character, it moves to the next character in the alphabet. For example, `'a'` becomes `'b'`, `'b'` becomes `'c'`, and so on. However, when you reach `'z'`, the next character wraps around to `'a'`. This is important to consider because our problem allows for at most one cyclic increment on any character in `str1`.\n\n---\n\n### Approach 1: Brute Force (Time Limit Exceeded)\n\n#### Intuition\n\nIf `str2` is already a subsequence of `str1` without any modifications, we can immediately return `true`. However, if `str2` is not a subsequence, we need to explore the possibility of transforming `str2` into a subsequence by incrementing certain characters in `str1`. A logical first solution would be to consider all possible combinations of characters in `str1` that could be incremented. For each character in `str1`, we have two options: either increment it or leave it unchanged.\n\nTo explore all combinations, we can use a bitmask where each bit represents whether a particular character in `str1` should be incremented. For example, if `str1` has `3` characters, there are $2^3 = 8$ possible combinations $(000, 001, 010, 011, 100, 101, 110, 111)$. A bit set to `1` means the character is incremented, and a bit set to `0` means it is not.\n\nTo implement this, we need two helper functions:\n\n1. `getNextChar`: This function takes a single character as input and returns the next character in the alphabet, wrapping from `'z'` to `'a'`\n2. `isSubsequence`: This function checks if `str2` is a subsequence of `str1` by iterating through both strings and ensuring that all characters of `str2` appear in order within `str1`.\n\nIn the main function `canMakeSubsequence`, we iterate through all possible bitmasks. For each mask, we create a temporary copy of `str1` and apply the increments based on the mask. We then check if `str2` is a subsequence of the modified `str1`. If it is, we return `true`. If no combination works, we return `false`.\n\nUnfortunately, this approach will time out due to its exponential time complexity, as it explores all possible combinations of character increments.\n\n#### Algorithm\n\n- Define the helper function `getNextChar` to get the next character cyclically:\n  - If the character is `'z'`, return `'a'`.\n  - Otherwise, return the next character by incrementing the ASCII value.\n\n- Define the helper function `isSubsequence` to check if `str2` is a subsequence of `str1`:\n  - Initialize `str1Index` and `str2Index` to `0` to track positions in both strings.\n  - Traverse through both strings with a `while` loop:\n    - If the characters at `str1[str1Index]` and `str2[str2Index]` match, increment `str2Index`.\n    - Always increment `str1Index`.\n  - After the loop, check if all characters in `str2` were matched (i.e., if `str2Index == lengthStr2`).\n\n- Define the main function `canMakeSubsequence`:\n  - Get the length of `str1`.\n  - Iterate through all possible combinations of character increments in `str1` using bitmasking (from `0` to `(1 << lengthStr1) - 1`):\n    - For each combination (`mask`), create a temporary string `temp` that is a copy of `str1`.\n    - For each character in `str1`, check if the corresponding bit in the `mask` is set:\n      - If set, increment the character in `temp` using `getNextChar`.\n    - After modifying `temp`, check if `str2` is a subsequence of `temp` using the `isSubsequence` function.\n    - If `str2` is found as a subsequence, return `true`.\n\n- If no combination makes `str2` a subsequence of `str1`, return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string `str1` and $m$ be the length of the string `str2`.\n\n- Time complexity: $O(2^n \\cdot n \\cdot m)$\n\n    The algorithm iterates through all possible combinations of character increments using a bitmask. There are $2^n$ possible masks, and for each mask, it modifies the string `str1` in $O(n)$ time. After modifying the string, it checks if `str2` is a subsequence of the modified string, which takes $O(n \\cdot m)$ time in the worst case. Therefore, the overall time complexity is $O(2^n \\cdot n \\cdot m)$.\n\n- Space complexity: $O(n)$\n\n    The algorithm uses an additional string `temp` of length $n$ to store the modified version of `str1`. Additionally, it uses a few integer variables to keep track of indices and lengths. The space used for these variables is constant and does not depend on the input size. Therefore, the space complexity is $O(n)$.\n\n---\n\n### Approach 2: Optimized Single Pass (Two Pointer)\n\n#### Intuition\n\nTo solve this more efficiently, we can aim to complete the task in a single pass through `str1`. We start by iterating through `str1` and `str2` simultaneously using two pointers. For each character in `str1`, we check if it matches the current character in `str2` or if it can be incremented to match `str2`. Specifically, we check if `str1[str1Index]` is equal to `str2[str2Index]`, or if incrementing `str1[str1Index]` once (cyclically) results in `str2[str2Index]`. In an edge case, this means that after `'z'`, we wrap around to `'a'`.\n\nTo handle this cyclic increment, we need to consider two specific conditions: \n1. Direct Increment: If the character in `str1` can be directly incremented by one to match the character in `str2`, we use the condition `str1[str1Index] + 1 == str2[str2Index]`. \n   - For example, if `str1[str1Index]` is `'a'` and `str2[str2Index]` is `'b'`, then `'a' + 1` equals `'b'`.\n2. Wrap-Around: If the character in `str1` is `'z'`, incrementing it by one should wrap around to `'a'`. To handle this wrap-around, we use the condition `str1[str1Index] - 25 == str2[str2Index]`. This is because the ASCII value of `'z'` is `122`, and the ASCII value of `'a'` is `97`. So, `'z' + 1` would be `123`, which is out of the alphabet range. Instead, we subtract `25` to wrap around to `'a'`.\n \nThe algorithm is visualized below:\n\n!?!../Documents/2825/2825_two_pointer.json:770,555!?!\n\n> For a more comprehensive understanding of the two-pointer technique, explore the [Two Pointer Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/array-and-string/205/array-two-pointer-technique/). This resource provides an in-depth look at the two-pointer approach, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Initialize `str2Index` to `0` to keep track of the current position in `str2`.\n- Get the length of `str1` and `str2` and store them in `lengthStr1` and `lengthStr2`.\n\n- Loop through each character of `str1` with `str1Index` starting from `0`, stopping when either the end of `str1` or `str2` is reached:\n  - If the character `str1[str1Index]` matches `str2[str2Index]`, or if the character `str1[str1Index]` can be incremented or decremented (by `1` or by `25` respectively) to match `str2[str2Index]`:\n    - Move to the next character in `str2` by incrementing `str2Index`.\n  \n- After traversing `str1`, if `str2Index` equals `lengthStr2`, this means all characters in `str2` have been successfully matched with corresponding characters in `str1`. Return `true`.\n\n- If not all characters in `str2` were matched by the end of the loop, return `false`.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the length of the string `str1` and $m$ be the length of the string `str2`.\n\n- Time complexity: $O(n)$\n\n    The algorithm iterates through the string `str1` once using a single for loop. Within each iteration, it performs a constant amount of work (checking character equality and possible transformations). Therefore, the time complexity is linear with respect to the length of `str1`, which is $O(n)$.\n\n- Space complexity: $O(1)$\n\n    The algorithm uses a constant amount of extra space. It only uses a few integer variables (`str2Index`, `lengthStr1`, `lengthStr2`, and `str1Index`) to keep track of indices and lengths. The space used does not depend on the input size, so the space complexity is $O(1)$.\n\n---"
}