{
  "title": "Design Graph With Shortest Path Calculator",
  "problem_id": "2678",
  "frontend_id": "2642",
  "difficulty": "Hard",
  "problem_slug": "design-graph-with-shortest-path-calculator",
  "topics": [
    "Graph",
    "Design",
    "Heap (Priority Queue)",
    "Shortest Path"
  ],
  "description": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\nExample 1:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.",
      "images": [
        "https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png"
      ]
    }
  ],
  "constraints": [
    "1 <= n <= 100",
    "0 <= edges.length <= n * (n - 1)",
    "edges[i].length == edge.length == 3",
    "0 <= fromi, toi, from, to, node1, node2 <= n - 1",
    "1 <= edgeCosti, edgeCost <= 106",
    "There are no repeated edges and no self-loops in the graph at any point.",
    "At most 100 calls will be made for addEdge.",
    "At most 100 calls will be made for shortestPath."
  ],
  "follow_ups": [],
  "hints": [
    "After adding each edge, update your graph with the new edge, and you can calculate the shortest path in your graph each time the shortestPath method is called.",
    "Use dijkstra’s algorithm to calculate the shortest paths."
  ],
  "code_snippets": {
    "cpp": "class Graph {\npublic:\n    Graph(int n, vector<vector<int>>& edges) {\n        \n    }\n    \n    void addEdge(vector<int> edge) {\n        \n    }\n    \n    int shortestPath(int node1, int node2) {\n        \n    }\n};\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph* obj = new Graph(n, edges);\n * obj->addEdge(edge);\n * int param_2 = obj->shortestPath(node1,node2);\n */",
    "java": "class Graph {\n\n    public Graph(int n, int[][] edges) {\n        \n    }\n    \n    public void addEdge(int[] edge) {\n        \n    }\n    \n    public int shortestPath(int node1, int node2) {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */",
    "python": "class Graph(object):\n\n    def __init__(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        \"\"\"\n        \n\n    def addEdge(self, edge):\n        \"\"\"\n        :type edge: List[int]\n        :rtype: None\n        \"\"\"\n        \n\n    def shortestPath(self, node1, node2):\n        \"\"\"\n        :type node1: int\n        :type node2: int\n        :rtype: int\n        \"\"\"\n        \n\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph(n, edges)\n# obj.addEdge(edge)\n# param_2 = obj.shortestPath(node1,node2)",
    "python3": "class Graph:\n\n    def __init__(self, n: int, edges: List[List[int]]):\n        \n\n    def addEdge(self, edge: List[int]) -> None:\n        \n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        \n\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph(n, edges)\n# obj.addEdge(edge)\n# param_2 = obj.shortestPath(node1,node2)",
    "c": "\n\n\ntypedef struct {\n    \n} Graph;\n\n\nGraph* graphCreate(int n, int** edges, int edgesSize, int* edgesColSize) {\n    \n}\n\nvoid graphAddEdge(Graph* obj, int* edge, int edgeSize) {\n    \n}\n\nint graphShortestPath(Graph* obj, int node1, int node2) {\n    \n}\n\nvoid graphFree(Graph* obj) {\n    \n}\n\n/**\n * Your Graph struct will be instantiated and called as such:\n * Graph* obj = graphCreate(n, edges, edgesSize, edgesColSize);\n * graphAddEdge(obj, edge, edgeSize);\n \n * int param_2 = graphShortestPath(obj, node1, node2);\n \n * graphFree(obj);\n*/",
    "csharp": "public class Graph {\n\n    public Graph(int n, int[][] edges) {\n        \n    }\n    \n    public void AddEdge(int[] edge) {\n        \n    }\n    \n    public int ShortestPath(int node1, int node2) {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.AddEdge(edge);\n * int param_2 = obj.ShortestPath(node1,node2);\n */",
    "javascript": "/**\n * @param {number} n\n * @param {number[][]} edges\n */\nvar Graph = function(n, edges) {\n    \n};\n\n/** \n * @param {number[]} edge\n * @return {void}\n */\nGraph.prototype.addEdge = function(edge) {\n    \n};\n\n/** \n * @param {number} node1 \n * @param {number} node2\n * @return {number}\n */\nGraph.prototype.shortestPath = function(node1, node2) {\n    \n};\n\n/** \n * Your Graph object will be instantiated and called as such:\n * var obj = new Graph(n, edges)\n * obj.addEdge(edge)\n * var param_2 = obj.shortestPath(node1,node2)\n */",
    "typescript": "class Graph {\n    constructor(n: number, edges: number[][]) {\n        \n    }\n\n    addEdge(edge: number[]): void {\n        \n    }\n\n    shortestPath(node1: number, node2: number): number {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * var obj = new Graph(n, edges)\n * obj.addEdge(edge)\n * var param_2 = obj.shortestPath(node1,node2)\n */",
    "php": "class Graph {\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     */\n    function __construct($n, $edges) {\n        \n    }\n  \n    /**\n     * @param Integer[] $edge\n     * @return NULL\n     */\n    function addEdge($edge) {\n        \n    }\n  \n    /**\n     * @param Integer $node1\n     * @param Integer $node2\n     * @return Integer\n     */\n    function shortestPath($node1, $node2) {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * $obj = Graph($n, $edges);\n * $obj->addEdge($edge);\n * $ret_2 = $obj->shortestPath($node1, $node2);\n */",
    "swift": "\nclass Graph {\n\n    init(_ n: Int, _ edges: [[Int]]) {\n        \n    }\n    \n    func addEdge(_ edge: [Int]) {\n        \n    }\n    \n    func shortestPath(_ node1: Int, _ node2: Int) -> Int {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * let obj = Graph(n, edges)\n * obj.addEdge(edge)\n * let ret_2: Int = obj.shortestPath(node1, node2)\n */",
    "kotlin": "class Graph(n: Int, edges: Array<IntArray>) {\n\n    fun addEdge(edge: IntArray) {\n        \n    }\n\n    fun shortestPath(node1: Int, node2: Int): Int {\n        \n    }\n\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * var obj = Graph(n, edges)\n * obj.addEdge(edge)\n * var param_2 = obj.shortestPath(node1,node2)\n */",
    "dart": "class Graph {\n\n  Graph(int n, List<List<int>> edges) {\n    \n  }\n  \n  void addEdge(List<int> edge) {\n    \n  }\n  \n  int shortestPath(int node1, int node2) {\n    \n  }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = Graph(n, edges);\n * obj.addEdge(edge);\n * int param2 = obj.shortestPath(node1,node2);\n */",
    "golang": "type Graph struct {\n    \n}\n\n\nfunc Constructor(n int, edges [][]int) Graph {\n    \n}\n\n\nfunc (this *Graph) AddEdge(edge []int)  {\n    \n}\n\n\nfunc (this *Graph) ShortestPath(node1 int, node2 int) int {\n    \n}\n\n\n/**\n * Your Graph object will be instantiated and called as such:\n * obj := Constructor(n, edges);\n * obj.AddEdge(edge);\n * param_2 := obj.ShortestPath(node1,node2);\n */",
    "ruby": "class Graph\n\n=begin\n    :type n: Integer\n    :type edges: Integer[][]\n=end\n    def initialize(n, edges)\n        \n    end\n\n\n=begin\n    :type edge: Integer[]\n    :rtype: Void\n=end\n    def add_edge(edge)\n        \n    end\n\n\n=begin\n    :type node1: Integer\n    :type node2: Integer\n    :rtype: Integer\n=end\n    def shortest_path(node1, node2)\n        \n    end\n\n\nend\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph.new(n, edges)\n# obj.add_edge(edge)\n# param_2 = obj.shortest_path(node1, node2)",
    "scala": "class Graph(_n: Int, _edges: Array[Array[Int]]) {\n\n    def addEdge(edge: Array[Int]): Unit = {\n        \n    }\n\n    def shortestPath(node1: Int, node2: Int): Int = {\n        \n    }\n\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * val obj = new Graph(n, edges)\n * obj.addEdge(edge)\n * val param_2 = obj.shortestPath(node1,node2)\n */",
    "rust": "struct Graph {\n\n}\n\n\n/** \n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl Graph {\n\n    fn new(n: i32, edges: Vec<Vec<i32>>) -> Self {\n        \n    }\n    \n    fn add_edge(&self, edge: Vec<i32>) {\n        \n    }\n    \n    fn shortest_path(&self, node1: i32, node2: i32) -> i32 {\n        \n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * let obj = Graph::new(n, edges);\n * obj.add_edge(edge);\n * let ret_2: i32 = obj.shortest_path(node1, node2);\n */",
    "racket": "(define graph%\n  (class object%\n    (super-new)\n    \n    ; n : exact-integer?\n    ; edges : (listof (listof exact-integer?))\n    (init-field\n      n\n      edges)\n    \n    ; add-edge : (listof exact-integer?) -> void?\n    (define/public (add-edge edge)\n      )\n    ; shortest-path : exact-integer? exact-integer? -> exact-integer?\n    (define/public (shortest-path node1 node2)\n      )))\n\n;; Your graph% object will be instantiated and called as such:\n;; (define obj (new graph% [n n] [edges edges]))\n;; (send obj add-edge edge)\n;; (define param_2 (send obj shortest-path node1 node2))",
    "erlang": "-spec graph_init_(N :: integer(), Edges :: [[integer()]]) -> any().\ngraph_init_(N, Edges) ->\n  .\n\n-spec graph_add_edge(Edge :: [integer()]) -> any().\ngraph_add_edge(Edge) ->\n  .\n\n-spec graph_shortest_path(Node1 :: integer(), Node2 :: integer()) -> integer().\ngraph_shortest_path(Node1, Node2) ->\n  .\n\n\n%% Your functions will be called as such:\n%% graph_init_(N, Edges),\n%% graph_add_edge(Edge),\n%% Param_2 = graph_shortest_path(Node1, Node2),\n\n%% graph_init_ will be called before every test case, in which you can do some necessary initializations.",
    "elixir": "defmodule Graph do\n  @spec init_(n :: integer, edges :: [[integer]]) :: any\n  def init_(n, edges) do\n    \n  end\n\n  @spec add_edge(edge :: [integer]) :: any\n  def add_edge(edge) do\n    \n  end\n\n  @spec shortest_path(node1 :: integer, node2 :: integer) :: integer\n  def shortest_path(node1, node2) do\n    \n  end\nend\n\n# Your functions will be called as such:\n# Graph.init_(n, edges)\n# Graph.add_edge(edge)\n# param_2 = Graph.shortest_path(node1, node2)\n\n# Graph.init_ will be called before every test case, in which you can do some necessary initializations."
  },
  "solution": "[TOC]\n\n## Solution\n\n--- \n\n### Overview\n\nImagine you're tasked with navigating a complex web of interconnected locations, each with its unique path and cost associated with traveling from one place to another. This is precisely the challenge presented in this problem.\n\nYou're given a directed weighted graph, represented by an array of edges. Each edge signifies a one-way connection between two locations, complete with a cost. Your mission is to create a \"Graph\" class that can efficiently manage this network and provide two essential services.\n\n1. **Setting Up the Map (`Graph(int n, int[][] edges)`):** Just like preparing a map for a journey, you initialize the graph with \"n\" locations and the given edges. This step lays out the foundation for your navigation.\n\n2. **Plotting New Routes (`addEdge(int[] edge)`):** As your journey unfolds, you'll come across new routes. The \"addEdge\" method allows you to add these paths to your map. It's worth noting that this method ensures no duplicate paths between locations.\n\n3. **Finding the Optimal Path (`int shortestPath(int node1, int node2)`):** The core of this adventure lies in discovering the shortest and most cost-effective path from one location to another. This method calculates the minimum cost required to travel from \"node1\" to \"node2.\" If a path doesn't exist, it signals your GPS to return -1.\n\nSolving this problem involves creating a powerful navigation tool (the \"Graph\" class) that not only builds and updates the map as new routes are discovered but also efficiently guides you to your destination, ensuring that you reach your target location with the least possible cost.\n\nThis problem mirrors real-world scenarios where you might be navigating transportation networks, optimizing data flow in networks, or even finding the shortest connections in social networks. So, crafting a robust solution here not only solves the immediate challenge but can also have practical applications in various fields.\n\n### Approach 1: Dijkstra's Algorithm\n\n#### Intuition\n\nIf you are not familiar with Dijkstra's Algorithm, please refer to our explore cards [Dijkstra's Algorithm](https://leetcode.com/explore/learn/card/graph/622/single-source-shortest-path-algorithm/3862/). We will focus on the usage in this article and not the underlying principles or implementation details.\n\nWe first use Dijkstra's algorithm, a well-known method for finding the shortest path in weighted graphs, which is particularly effective for this type of problem. The algorithm maintains a priority queue of nodes to explore, prioritizing those with the lowest tentative distances.\n\nWe begin by setting the cost of the source node to 0 and enqueue it in a priority queue. Simultaneously, we initialize an array to store the cost associated with each node when starting from the source node. While there are nodes remaining in the queue, we dequeue the node with the lowest cost, examine whether it corresponds to the destination node, and return its cost if it does. If not, we explore its neighboring nodes, compute new costs for the neighboring nodes, and if these new costs are lower than the previously recorded costs in our node cost array, we enqueue the neighboring nodes into the priority queue. In the event that the destination node cannot be reached, we return -1 to indicate the absence of a viable path.\n\nWe implement this approach by creating a `Graph` class with methods for initialization, adding edges, and finding the shortest path using Dijkstra's algorithm. This approach logically addresses the problem's requirements while leveraging a well-established algorithm for efficiency and correctness.\n\n!?!../Documents/2642/design_graph_with_shortest_path_calculator.json:3000,1687!?!\n\n\n#### Algorithm\n\n1. **Initialization:**\n   - When we initialize the `Graph` class with `n` nodes and a list of `edges`, we create an adjacency list representation for the directed weighted graph.\n   - We initialize an empty adjacency list `adj_list`, where each node's outgoing edges will be stored along with their cost.\n\n2. **Adding Edges:**\n   - When we call the `addEdge` method to add an edge to the graph, we provide an `edge` in the form of a list `[from, to, edgeCost]`.\n   - We extract the `from_node`, `to_node`, and `cost` from the input edge.\n   - We append a tuple/pair `(to_node, cost)` to the adjacency list entry for `from_node`. This represents a directed edge from `from_node` to `to_node` with the specified cost.\n\n3. **Shortest Path Calculation:**\n   - When we call the `shortestPath` method to find the minimum cost path from `node1` to `node2`, we use Dijkstra's algorithm.\n   - We initialize an array `costForNode` to keep track of the minimum costs to reach each node when starting from `node1` and a priority queue `pq` to explore nodes in ascending order of their accumulated cost from `node1`.\n   - We set `costForNode[node1]` to 0 since we are starting here.\n   - We start by adding `(0, node1)` to `pq` with an initial cost of 0 for `node1`.\n   - While `pq` is not empty, we continue exploring nodes.\n   - For each iteration:\n     - We pop the node with the smallest accumulated cost (`curr_cost`) from `pq`.\n     - If `curr_node` is equal to `node2`, we have found the shortest path, and we return `curr_cost`.\n     - We iterate through the neighbors of `curr_node` stored in the adjacency list.\n     - For each neighbor, we calculate the new cost (`new_cost`) by adding the cost of the current edge to the `curr_cost`.\n     - If the neighbor's `new_cost` is less than its cost in `costForNode` (`costForNode[node1]`), we add `(new_cost, neighbor)` to `pq`, which means we will explore this neighbor with the updated cost. We additionally assign the value of `new_cost` to `costForNode[node1]`.\n   - If the priority queue is empty and we have not found `node2`, it means there is no path from `node1` to `node2`, so we return -1.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $E$ be number of edges in the graph when the call to any method is made.\nLet $V$ be the number of vertices in the graph when the call to any method is made.\nLet $N$ be the maximum number of calls made to `addEdge`.\nLet $M$ be the maximum number of calls made to `shortestPath`.\n\n* Time complexity: $O(N + M\\cdot (V + E\\cdot logV))$\n  - initialization: $O(E + V)$. Initializing a list to the size of $V$ costs $O(V)$ and iterating over all the edges costs $O(E)$\n  - addEdge: $O(N)$. Appending an element to a list costs $O(1)$, and when this operation is performed $N$ times, it results in a linear time complexity of $O(N)$.\n  - shortestPath: $O(M\\cdot (V + E\\cdot logV))$. Initializing the `costForNode` list will incur a time complexity of $O(V)$. The time complexity for Dijkstra's algorithm is $(E\\cdot logV)$. Calling `shortestPath` $M$ times leads to a combined time complexity of $O(M\\cdot (V + E\\cdot logV))$.\n\n* Space complexity: $O(E + V + N)$\n  - initialization: $O(E + V)$. This is the cost to initialize the adjacency list.\n  - addEdge: $O(N)$. Adding an element in the adjacency list will incur a space complexity of $O(1)$, and when this operation is performed $N$ times, it results in a linear space complexity of $O(N)$.\n  - shortestPath: $O(E + V)$. The `costForNode` list will incur a space complexity of $O(V)$. The priority queue will will incur a space complexity of $O(E)$.\n\n---\n\n### Approach 2: Floyd–Warshall algorithm\n\n#### Intuition\n\nWe start by considering how to represent the graph. Given that it's a weighted directed graph, we opt for an adjacency matrix to store the edge costs between nodes. This matrix, `adj_matrix`, will be initialized with a very large value (infinity) to signify that there's no direct edge between two nodes.\n\nIn the constructor, we take the number of nodes `n` and the initial `edges` as input. We initialize the adjacency matrix with infinity values for all pairs of nodes. Then, we iterate through the given edges and update the corresponding positions in the adjacency matrix with the edge costs. To maintain consistency, we also set the diagonal entries to 0 since the cost from a node to itself is zero.\n\n**Floyd-Warshall Algorithm:** We recognize the need to find the shortest paths between all pairs of nodes efficiently. To achieve this, we implement the Floyd-Warshall algorithm. We use nested loops to iterate through all possible intermediate nodes (`k`), source nodes (`i`), and destination nodes (`j`). For each pair of nodes (`i, j`), we update the minimum cost if there's a shorter path through the intermediate node (`k`).\n\nIn the `addEdge` method, we address the requirement to add a new edge to the graph. We take the edge information as input (from_node, to_node, and cost). To update the adjacency matrix efficiently, we iterate through all pairs of nodes (`i, j`) and check if the path from `i` to `j` can be improved by going through the newly added edge. If there's an improvement, we update the cost accordingly. This is commonly known as the \"relaxation\" step.\n\n**Finding Shortest Path:** In the `shortestPath` method, we provide a simple interface for users to find the shortest path between two nodes. We return the cost stored in the adjacency matrix for the given pair of nodes (node1, node2). Since we have already relaxed all paths in the `addEdge` method, the adjacent matrix is guaranteed to store the cost of the shortest path. If the cost is still infinite, it indicates there's no path between those nodes, and we return -1.\n\nThe key insight here is that the Floyd-Warshall algorithm efficiently computes the shortest paths between all pairs of nodes, making the `shortestPath` method fast and time-constant. \n\n#### Algorithm\n\n1. **Initialization:**\n   - When we initialize the `Graph` class with `n` nodes and a list of `edges`, we create an adjacency matrix representation for the directed weighted graph.\n   - We initialize an empty adjacency matrix `adj_matrix` of size `n x n`, where `n` is the number of nodes.\n   - For each edge in the input `edges`, we update the corresponding entry in the adjacency matrix with the provided cost.\n   - We set the diagonal elements of the adjacency matrix to 0 because the cost to reach a node from itself is always 0.\n\n2. **Floyd-Warshall Algorithm:**\n   - After initializing the adjacency matrix, we apply the Floyd-Warshall algorithm to compute the shortest paths between all pairs of nodes.\n   - We use three nested loops:\n     - The outermost loop iterates over all intermediate nodes (indexed by `i`).\n     - The middle loop iterates over all source nodes (indexed by `j`).\n     - The innermost loop iterates over all destination nodes (indexed by `k`).\n   - During each iteration, we update the entry `adj_matrix[j][k]` by taking the minimum of its current value and the sum of the values `adj_matrix[j][i]` and `adj_matrix[i][k]`. This represents the minimum cost to reach node `k` from node `j` via an intermediate node `i`.\n\n3. **Adding Edges:**\n   - When we call the `addEdge` method to add an edge to the graph, we provide an `edge` in the form of a list `[from, to, edgeCost]`.\n   - We iterate over all pairs of nodes in the adjacency matrix and update the entry `adj_matrix[i][j]` by taking the minimum of its current value and the sum of the values `adj_matrix[i][from_node]`, `adj_matrix[to_node][j]`, and `cost`. This represents the updated minimum cost considering the new edge.\n\n4. **Shortest Path Calculation:**\n   - When we call the `shortestPath` method to find the minimum cost path from `node1` to `node2`, we check if the value at `adj_matrix[node1][node2]` is still equal to infinity(`inf`). If it is, there is no path between the two nodes, so we return -1.\n   - Otherwise, we return `adj_matrix[node1][node2]`, which represents the minimum cost to reach `node2` from `node1` based on the computed shortest paths.\n\n\n#### Implementation#### Complexity Analysis\n\nLet $E$ be number of edges in the graph when the call to any method is made.\nLet $V$ be the number of vertices in the graph when the call to any method is made.\nLet $N$ be the maximum number of calls made to `addEdge`.\nLet $M$ be the maximum number of calls made to `shortestPath`.\n\n* Time complexity: $O(M + N\\cdot V^2 + V^3)$\n  - initialization: $O(V^3)$. The Floyd-Warshall Algorithm incurs a cost of $O(V^3)$ to find the minimum cost between all pairs of vertices.\n  - addEdge: $O(N\\cdot V^2)$. When adding an edge, we iterate over the whole matrix to check if the new edge lowers the cost between any of the vertices. This operation costs $O(V^2)$. When this operation is performed $N$ times, it results in a time complexity of $O(N\\cdot V^2)$.\n  - shortestPath: $O(M)$. Finding the `shortestPath` doesn't require any additional computation. Hence, it incurs a constant time complexity of $O(1)$. When this operation is performed $M$ times, it results in a linear time complexity of $O(M)$.\n\n* Space complexity:  $$O(V^2)$$\n  - initialization: $O(V^2)$. We initialize a 2-D adjacency matrix that stores the minimum cost between all vertices. This matrix incurs a cost of $O(V^2)$.\n  - addEdge: $O(1)$. We will not need any extra space to add an edge.\n  - shortestPath: $O(1)$. We will not need any extra space to return the cost of the shortest path.\n---\n\n### Notes:\nIf there is a significant imbalance between the frequency of `shortestPath` calls compared to the frequency of `addEdge` calls, the choice between using the Floyd-Warshall algorithm and Dijkstra's algorithm should be based on the number of times these two operations are performed:\n\n- When `shortestPath` is called much more often than `addEdge`, it is more efficient to utilize the Floyd-Warshall algorithm.\n- Conversely, if `addEdge` is called significantly more often than `shortestPath`, it is more practical to employ Dijkstra's algorithm for this problem."
}