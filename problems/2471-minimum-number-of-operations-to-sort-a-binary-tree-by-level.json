{
  "title": "Minimum Number of Operations to Sort a Binary Tree by Level",
  "problem_id": "2558",
  "frontend_id": "2471",
  "difficulty": "Medium",
  "problem_slug": "minimum-number-of-operations-to-sort-a-binary-tree-by-level",
  "topics": [
    "Tree",
    "Breadth-First Search",
    "Binary Tree"
  ],
  "description": "You are given the root of a binary tree with unique values.\nIn one operation, you can choose any two nodes at the same level and swap their values.\nReturn the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.\nThe level of a node is the number of edges along the path between it and the root node.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
  "examples": [
    {
      "example_num": 1,
      "example_text": "Input: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]\nOutput: 3\nExplanation:\n- Swap 4 and 3. The 2nd level becomes [3,4].\n- Swap 7 and 5. The 3rd level becomes [5,6,8,7].\n- Swap 8 and 7. The 3rd level becomes [5,6,7,8].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png"
      ]
    },
    {
      "example_num": 2,
      "example_text": "Input: root = [1,3,2,7,6,5,4]\nOutput: 3\nExplanation:\n- Swap 3 and 2. The 2nd level becomes [2,3].\n- Swap 7 and 4. The 3rd level becomes [4,6,5,7].\n- Swap 6 and 5. The 3rd level becomes [4,5,6,7].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png"
      ]
    },
    {
      "example_num": 3,
      "example_text": "Input: root = [1,2,3,4,5,6]\nOutput: 0\nExplanation: Each level is already sorted in increasing order so return 0.",
      "images": [
        "https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png"
      ]
    }
  ],
  "constraints": [
    "The number of nodes in the tree is in the range [1, 105].",
    "1 <= Node.val <= 105",
    "All the values of the tree are unique."
  ],
  "follow_ups": [],
  "hints": [
    "We can group the values level by level and solve each group independently.",
    "Do BFS to group the value level by level.",
    "Find the minimum number of swaps to sort the array of each level.",
    "While iterating over the array, check the current element, and if not in the correct index, replace that element with the index of the element which should have come."
  ],
  "code_snippets": {
    "cpp": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minimumOperations(TreeNode* root) {\n        \n    }\n};",
    "java": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int minimumOperations(TreeNode root) {\n        \n    }\n}",
    "python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minimumOperations(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        ",
    "python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minimumOperations(self, root: Optional[TreeNode]) -> int:\n        ",
    "c": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint minimumOperations(struct TreeNode* root) {\n    \n}",
    "csharp": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int MinimumOperations(TreeNode root) {\n        \n    }\n}",
    "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minimumOperations = function(root) {\n    \n};",
    "typescript": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction minimumOperations(root: TreeNode | null): number {\n    \n};",
    "php": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function minimumOperations($root) {\n        \n    }\n}",
    "swift": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func minimumOperations(_ root: TreeNode?) -> Int {\n        \n    }\n}",
    "kotlin": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun minimumOperations(root: TreeNode?): Int {\n        \n    }\n}",
    "dart": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int minimumOperations(TreeNode? root) {\n    \n  }\n}",
    "golang": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc minimumOperations(root *TreeNode) int {\n    \n}",
    "ruby": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @return {Integer}\ndef minimum_operations(root)\n    \nend",
    "scala": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def minimumOperations(root: TreeNode): Int = {\n        \n    }\n}",
    "rust": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        \n    }\n}",
    "racket": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (minimum-operations root)\n  (-> (or/c tree-node? #f) exact-integer?)\n  )",
    "erlang": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec minimum_operations(Root :: #tree_node{} | null) -> integer().\nminimum_operations(Root) ->\n  .",
    "elixir": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec minimum_operations(root :: TreeNode.t | nil) :: integer\n  def minimum_operations(root) do\n    \n  end\nend"
  },
  "solution": "[TOC]\n\n## Solution\n\n---\n\n### Approach 1: Hash Map\n\n#### Intuition\n\nOur first task is to traverse the tree level by level. This is known as a level order traversal of a tree. Level-order traversal involves exploring all the nodes at a given depth (or level) before moving to the next level. In other words, it prioritizes breadth-wise exploration of the tree before progressing depth-wise. To achieve this, we use Breadth-First Search (BFS).\n\nWe use a queue to perform BFS on the tree. As we process each node, we add all its children to the queue. This ensures that after all nodes at the current level are explored, the remaining elements in the queue represent all nodes at the next level. To process nodes at each level together, we can record the size of the queue at the start of each iteration and handle exactly that many nodes in the current level.\n\nOnce we retrieve the nodes at each level, our second task is to sort the values of the nodes at that level. While there are many efficient sorting algorithms, the problem specifically requires sorting the values with the minimum number of in-place swaps. The cycle sort algorithm meets our requirements perfectly.\n\nThe cycle sort algorithm works by cyclically placing each element in its correct sorted position by swapping it with the value currently in that position. For example, consider the array `[3, 0, 1]`. Since the correct position of `3` is index `2`, we swap it with the value at index `2` (i.e., `1`). After the swap, the array becomes `[1, 0, 3]`. While `3` is now in the correct position, `1` and `0` are still not. Next, we place `1` in its correct position (index `1`), and the process continues until the array is sorted. This cyclical placement gives the algorithm its name, cycle sort.\n\nReturning to the problem, after obtaining the nodes of a level (in an arbitrary order), we create a sorted copy of this list based on the values of the nodes. This allows us to determine the correct sorted index for each value. To efficiently track the positions of nodes, we use a map that stores each value and its current index. As we iterate through the list of nodes, we check if a node is already in its correct position. If not, we perform a swap to move it to the correct position, updating the map accordingly. This process is repeated until all nodes in the level are sorted.\n\nWe accumulate the total swaps needed to sort each level. At the end of the BFS, we can return this total as our answer.\n\n> For a more comprehensive understanding of Breadth-First Search on trees, check out the [Queue and BFS Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/). This resource provides an in-depth look at the BFS algorithm, explaining its key concepts and applications with a variety of problems to solidify understanding of the pattern.\n\n#### Algorithm\n\n- Initialize:\n  - a `queue` to store nodes for BFS traversal.\n  - a variable `totalSwaps` to track the total number of operations needed.\n- Add the `root` node to the queue to begin traversal.\n- While the queue is not empty:\n  - Get the size of the current level using the queue size.\n  - Initialize an array `levelValues` of size equal to the current level size.\n  - For each node at the current level:\n    - Remove the node from the queue.\n    - Store the node's value in the `levelValues` array.\n    - Add the left and right children of the current node to `queue` if they exist.\n  - Add minimum swaps needed for the current level to `totalSwaps`.\n  - Continue to the next level.\n- Return `totalSwaps` as the final answer.\n\nFor calculating minimum swaps (`getMinSwaps` function):\n- Initialize a variable `swaps` to track swaps needed for the current level.\n- Create a copy of the input array as the `target` array.\n- Sort the `target` array to get the desired order.\n- Initialize a map `pos` to store current positions of values.\n- Store positions of all values from the original array in the `pos` map.\n- For each position in the `original` array:\n  - If the value at the current position doesn't match the `target` array:\n    - Increment `swaps` counter.\n    - Get the position of desired value from `pos`.\n    - Update the position of the current value in `pos`.\n    - Update value in the `original` array at swapped position.\n- Return total `swaps` needed for current level.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the total number of nodes in the binary tree.\n\n- Time complexity: $O(n \\log n)$\n\n    The BFS traversal visits each node exactly once, contributing $O(n)$. At each level, we perform sorting of the level values array which costs $O(w \\log w)$ where $w$ is the width of that level. \n    \n    The position mapping and swap calculations take $O(w)$ time. In the worst case when the tree is a complete binary tree, $w$ could be $n/2$, making the complexity $2 \\cdot O(n) + O(n \\log n) = O(n \\log n)$.\n\n- Space complexity: $O(n)$\n\n    The queue used for BFS will store at most $w$ nodes at any time, where $w$ is the maximum width of the tree at any level. The `levelValues` array also stores $w$ elements for the current level. The map in `getMinSwaps` stores positions for $w$ elements. \n    \n    The temporary arrays (`original` and `target`) also use $O(w)$ space. Since all these data structures are bounded by the maximum width of the tree, the overall space complexity is $O(w)$. In the worst case of a complete binary tree, this becomes $O(n)$.\n\n---\n\n### Approach 2: Bit Manipulation\n\n#### Intuition\n\nIn the previous solution, we used two arrays - one for the original values and one for the sorted values. Additionally, we needed a map to keep track of the current positions of each value. This required maintaining three separate data structures and constantly updating the hash map during swaps. This approach was cumbersome and took up a lot of redundant space. Let's try to make the swapping process more space-efficient.\n\nThe key insight in this new approach is that we can combine a node's value and its position into a single number using bit manipulation. Since the problem guarantees that the values and positions won't exceed $2^{20}$, 20 bits are enough to store either piece of information. Therefore, a 40-bit long integer is technically enough to store both the value and position of a node, where the high 20 bits store the value and the low 20 bits store the original position. Let's see how the encoding works with a concrete example. Say we have a node with value 9 at position 6. To encode this:\n\n1. First, we shift 9 left by 20 bits: $9 << 20$. This moves all the bits of 9 to the left by 20 positions, leaving 20 zeros on the right.\n2. Then we add the position: $(9 << 20) + 6$. The 6 fills in some of those right-most zeros.\n\n![](../Figures/2471/encoding.png)\n\nWhen we need to get back the original position, we use a `MASK` (0xFFFFF). In binary, this mask has twenty 1's. When we perform an AND operation with the encoded value, it's like using a filter that only lets through the rightmost 20 bits â€” exactly where we stored our position.\n\n![](../Figures/2471/decoding.png)\n\nThe rest of the algorithm is similar to the previous approach, with some simplifications to the swapping process. We iterate through the sorted array, and for each position `i`, we check if the original position (extracted using the `MASK`) matches `i`. If it doesn't match, we know we need a swap. We perform the swap and decrement `i` to recheck the current position, as the newly swapped number might also need to be moved. We keep counting the swaps over the entire BFS and return the total count at the end as our answer.\n\n> For a more comprehensive understanding of bit manipulation techniques, check out the [Bit Manipulation Explore Card ðŸ”—](https://leetcode.com/explore/learn/card/bit-manipulation/). This resource provides an in-depth look at the various bit manipulation techniques and their applications in a variety of problems.\n\n#### Algorithm\n\n- Initialize constants `SHIFT` and `MASK` for bit manipulation operations.\n\n- Initialize:\n  - a `queue` to store nodes for BFS traversal.\n  - a variable `swaps` to track the total number of operations needed.\n- Add the `root` node to `queue` to begin traversal.\n- While the `queue` is not empty:\n  - Get the size of the current level using the `queue` size.\n  - Initialize an array `nodes` of type long to store encoded values and positions.\n  - For each node at the current level:\n    - Remove the node from the `queue`.\n    - Encode the node's value and current position into a single long integer:\n      - Shift the value left by 20 bits.\n      - Add the current position in the lower 20 bits.\n    - Store the encoded value in the `nodes` array.\n    - Add the left and right children to the `queue` if they exist.\n  - Sort the `nodes` array by values (using the higher 20 bits).\n  - For each position `i` in the sorted array:\n    - Extract the original position from the lower 20 bits using the AND operation with `MASK`.\n    - If the original position doesn't match the current position:\n      - Swap the nodes at the current and original positions.\n      - Decrement `i` to recheck current position.\n      - Increment the `swaps` counter.\n    - Continue until all the nodes are in the correct positions.\n- Return the total `swaps` as the final answer.\n\n#### Implementation#### Complexity Analysis\n\nLet $n$ be the total number of nodes in the binary tree.\n\n- Time complexity: $O(n \\log n)$\n\n    The BFS traversal visits each node exactly once, contributing $O(n)$. At each level, we sort the `nodes` array which takes $O(w \\log w)$ time, where $w$ is the width of that level. \n    \n    The swapping phase at each level takes $O(w)$ time. In the worst case of a complete binary tree, $w$ could be $n/2$, making the complexity $O(n) + O(n \\log n) = O(n \\log n)$.\n\n- Space complexity: $O(n)$\n\n    The `queue` used for the BFS will store at most $w$ nodes at any time, where $w$ is the maximum width of the tree at any level. The `nodes` array stores $w$ encoded values for the current level being processed. No additional data structures are needed since positions are encoded within the values themselves. \n    \n    Since all space usage is bounded by the maximum width of the tree, the overall space complexity is $O(w)$. In the worst case of a complete binary tree, this becomes $O(n)$.\n\n---"
}